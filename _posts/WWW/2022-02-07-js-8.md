---
published: true
title: "[JS] 연산자"
categories:
 - WWW
tags:
 - [WWW, JavaScript]
toc: true
toc_sticky: true
---

📖 **모던 자바스크립트 Deep Dive** 책으로 공부하고 정리한 필기입니다.
{: .notice--primary}

- 연산자
    - 하나 이상의 표현식을 대상으로 산술 & 할당 & 비교 & 논리 & 타입 & 지수 연산 등을 수행 ⇒ 하나의 값을 생성
    - 연산의 대상 ⇒ 피연산자
        - 피연산자 ⇒ 값으로 평가될 수 있는 표현식이어야 함
    - 피연산자 & 연산자의 조합으로 구성된 연산자 표현식 ⇒ 값으로 평가될 수 있는 표현식이어야 함

```jsx
// 산술 연산자
5 * 4 // 20

// 문자열 연결 연산자
'My name is ' + 'Lee' // 'My name is Lee'

// 할당 연산자
color = 'red' // 'red'

// 비교 연산자
3 > 5 // false

// 논리 연산자
true && false // false

// 타입 연산자
typeof 'Hi' // string
```

- 피연산자 == 값이라는 명사 역할
연산자 == 피연산자를 연산하여 새로운 값을 만드는 동사의 역할
- 피연산자 ⇒ 연산의 대상이 되어야 하므로 값으로 평가 가능해야 함
연산자 ⇒ 값으로 평가된 피연산자를 연산해 새로운 값 생성

<br/>

## 7.1 산술 연산자

- 산술 연산자
    - 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값 생성
    - 산술 연산이 불가능한 경우 ⇒ NaN 반환
    - 피연산자의 개수에 따라 산술 연산자 & 단항 산술 연산자 구분

### 7.1.1 이항 산술 연산자

- 이항 산술 연산자
    - 2개의 피연산자를 산술 연산하여 숫자 값 생성
    - 모든 이항 산술 연산자 ⇒ 피연산자의 값을 변경하는 부수 효과 없음
    - 어떤 연산 산술을 해도 피 연산자의 값이 바뀌는 경우 X ⇒ 언제나 새로운 값 생성

|이항 산술 연산자|의미|부수 효과|
|---|---|---|
|+|덧셈|X|
|-|뺄셈|X|
|*|곱셈|X|
|/|나눗셈|X|
|%|나머지|X|

```jsx
5 + 2; // 7
5 - 2; // 3
5 * 2; // 10
5 / 2; // 2.5
5 % 2; // 1
```

### 7.1.2 단항 산술 연산자

- 단항 산술 연산자
    - 1개의 피연산자를 산술 연산하여 숫자 값 생성

|단항 산술 연산자|의미|부수 효과|
|---|---|---|
|++|증가|O|
|- -|감소|O|
|+|효과X && 음수를 양수로 반전X|X|
|-|양수 → 음수 && 음수 → 양수로 반전한 값 반환|O|

- 주의할 점
    - 이항 산술 연산자와 달리 증가/감소(++/- -) 연산자 ⇒ 피연산자의 값을 변경하는 부수 효과 有
    - 증가(++)/감소(- -) 연산 실행 ⇒ 피연산자의 값을 변경하는 부수 효과 有
    - 증가(++)/감소(- -) 연산 ⇒ 피연산자의 값을 변경하는 암묵적 할당 실행

```jsx
var x = 1;

// ++ 연산자는 피연산자의 값을 변경하는 암묵적 할당을 실행
x++; // x = x + 1;
console.log(x); // 2

// -- 연산자는 피연산자의 값을 변경하는 암묵적 할당을 실행
x--; // x = x - 1;
console.log(x); // 1
```

- 증가(++)/감소(- -) 연산자 ⇒ 위치에 의미
    - 피연사자 앞에 위치한 전위 증가/감소 연산자
        - 피연산자의 값을 증가/감소 ⇒ 다른 연산 수행
    - 피연산자 뒤에 위치한 후위 증가/감소 연산자
        - 먼저 다른 연산 수행 ⇒ 피연산자의 값을 증가/감소

```jsx
var x = 5, result;

// 선할당 후증가(postfix inrement poerator)
result = x++;
console.log(result, x); // 5 6

// 선증가 후할당(prefix increment operator)
result = ++x;
console.log(result, x); // 7 7

// 선할당 후감소(postfix decrement operator)
result = x--;
console.log(result, x); // 7 6

// 선감소 후할당(prefix decrement operator)
result = --x;
console.log(result, x); // 5 5
```

```jsx
+10; // 10
+(-10); // -10
// + 단항 연산자 => 피연산자에 대한 효과 X && 음수 -> 양수 반전 X
```

- 숫자 타입이 아닌 피연산자 ⇒ + 단항 연산자 사용 ⇒ 피연산자를 숫자 타입으로 변환 & 반환
    - 피연산자 변경 X && 숫자 타입으로 변환한 값 생성 & 반환 ⇒ 부수 효과 X
- - 단항 연산자
    - 피연산자의 부호 반전한 값 반환
- + 단한 연산자
    - 숫자 타입이 아닌 피연산자에 사용 ⇒ 피연산자를 숫자 타입으로 변환 & 반환
    - 피연산자 변경 X & 부호 반전한 값 생성 & 반환 ⇒ 부수 효과 X

### 7.1.3 문자열 연결 연산자

- + 연산자
    - 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작
    - 그 외의 경우 ⇒ 산술 연산자로 동작

```jsx
'1' + 2; // '12'
1 + '2'; // '12'
```

```jsx
1 + 2; // 3
```

```jsx
1 + true; // 2
// true => 1로 타입 변환
```

```jsx
1 + false; // 1
// false => 0으로 타입 변환
```

```jsx
1 + null; // 1
// null => 0으로 타입 변환
```

```jsx
+undefined; // NaN
1 + undefined; // NaN
// undefined => 숫자로 타입 변환 X
```

- JS 엔진에 의해 암묵적 타입 변환(implicit
 coercion) or 타입 강제 변환(type conversion)될 수 있음
    - ex) 불리언 타입 ⇒ 0/1으로 변환 && +/- 단항 연산자

<br/>

## 7.2 할당 연산자

- 우항에 있는 피연산자의 평가 결과 ⇒ 좌항에 있는 변수에 할당
- 좌항의 변수 값에 할당 ⇒ 변수 값이 변하는 부수 효과 有

|할당 연산자|예|동일 표현|부수 효과|
|---|---|---|---|
|=|x = 5|x = 5|O|
|+=|x += 5|x = x + 5|O|
|-=|x -= 5|x = x - 5|O|
|*=|x *= 5|x = x * 5|O|
|/=|x /= 5|x = x / 5|O|
|%=|x %= 5|x = x % 5|O|

- 표현식
    - 값으로 평가될 수 있는 문
- 문
    - 표현식인 문 && 표현식이 아닌 문
- 할당문
    - 값으로 평가되는 표현식 문
    - 할당된 값으로 평가
    - 다른 변수에 할당 가능
    - 변수에 동일한 값을 연쇄 할당 가능

```jsx
var x;

// 할당문 => 표현식인 문
console.log(x = 10); // 10
```

```jsx
var a, b, c;

// 연쇄 할당, 오른쪽 => 왼쪽
// (1) c = 0 // 0
// (2) b = 0 // 0
// (3) a - 0 // 0
a = b = c = 0;

console.log(a, b, c); // 0 0 0
```

<br/>

## 7.3 비교 연산자

- 좌항 & 우항의 피연산자 비교 ⇒ 불리언 값으로 결과로 반환
- if문 && for문 같은 제어문의 조건식 사용 多

### 7.3.1 동등/일치 비교 연산자

- 좌항 & 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값 반환
- 비교하는 엄격성 차이 有
    - 동등 비교 연산자
        - 느슨한 비교
    - 일치 비교 연산자
        - 엄격한 비교

|비교 연산자|의미|사례|설명|부수 효과|

|==|동등 비교|x == y|x, y 값 동일|X|

|===|일치 비교|x === y|x, y 값 & 타입 동일|X|

|!=|동등비교|x ≠ y|x, y 값 다름|X|

|!==|불일치 비교| x ≠= y|x, y 값 & 타입 다름|X|

- 암묵적 타입 변환(implicit
 coercion) or 타입 강제 변환(type conversion)되기도 함
- 동등 비교(==) 연산자
    - 좌항 & 우항의 피연산자 비교 ⇒ 암묵적 타입 변환 ⇒ 타입 일치시킨 후 같은 값인지 비교
    - 좌항 & 우항의 피연산자가 타입이 다르더라도 암묵적 타입 변환 후 같은 값일 수 있다면 true 반환
    - 결과 예측이 어렵고 실수 多
    - 사용하지 않는 것을 추천
    - 등등 비교 연산자 대신 일치 비교(===) 연산자 사용 추천
- 일치 비교(===) 연산자
    - 좌항 & 우항의 피연산자 ⇒ 타입 & 값 같은 경우 ⇒ true 반환
        - 암묵적 타입 변환 X ⇒ 값 비교
    - 예측하기 쉬움
- 주의 사항
    - NaN
        - 자신과 일치하지 않는 유일한 값
        - 숫자가 NaN인지 조사 ⇒ 빌트인 함수 Number.isNaN 사용
        
        ```jsx
        NaN === NaN; // false
        ```
        
        - 숫자 0 주의
            - 양의 0 && 음의 0 존재 ⇒ 비교 시 true 반환
        
        ```jsx
        0 === -0; // true
        0 == -0; // true
        ```
        
- [Object.is](http://Object.is) 메서드
    - NaN & NaN 비교 or +0 & -0 비교 ⇒ 예측 가능한 정확한 비교 결과 반환
    - 그 외에는 일치 비교 연산자(===)와 동일하게 동작

```jsx
-0 === +0; // true
Object.is(-0, +0); // false

NaN === NaN; // false
Object.is(NaN, NaN); // true
```

- 부동등 비교 연산자(≠) & 불일치 비교 연산자(≠=)
    - 각각 동등 비교(==) 연산자 & 일치 비교(==) 연산자의 반대 개념

```jsx
// 부동등 비교
5 != 8; // true
5 != 5; // false
5 != '5'; // false

// 불일치 비교
5 !== 8; // true
5 !== 5; // false
5 !== '5'; // true
```

### 7.3.2 대소 관계 비교 연산자

- 피연산자의 크기를 불리언형 불리언 값 반환

|대소 관계 비교 연산자|예제|설명|부수 효과|
|---|---|---|---|
|>|x > y|x가 y보다 크다|X|
|<|x < y|x가 y보다 작다|X|
|≥=|x ≥ y|x가 y보다 크거나 같다|X|
|≤|x ≤ y|x가 y보다 자거나 같다|X|

```jsx
5 > 0; // true
5 > 5; // false
5 >= 5; // true
5 <= 5; // true
```

<br/>

## 7.4 삼항 조건 연산자

- 조건식의 평과 결과에 따라 반환할 값 결정
- 유일한 삼항 연산자
- 부수 효과 X
![image](https://user-images.githubusercontent.com/90893596/152689384-03ba6e24-cf2f-4e60-9a1b-47c3d234abd6.png)
- 삼항 조건 연산자 표현식
    - 값으로 펴가할 수 있는 표현식인 문
    - 값처럼 다른 표현식의 일부가 될 수 있어 유용

```jsx
var x = 10;

// 삼항 조건 연산자 표현식 == 표현식인 문 // 값처럼 사용 가능
var result = x % 2 ? '홀수' : '짝수';
console.log(result); // 짝수
```

- 조건에 따라 어떤 값을 결정해야하는 경우(수행할 문이 1개)
    - if ~ else 문보다 삼항 조건 연산자 표현식 사용 ⇒ 유리
- 조건에 따라 수행할 문이 하나가 아니라 여러 개인 경우
    - if ~ else문의 가독성이 더 좋음

<br/>

## 7.5 논리 연산자

- 우항 & 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 뜻함
- 논리 부정(!) 연산자
    - 언제나 불리언 값 반환
    - 피연산자가 반드시 불리언 값일 필요 X
    - 피연산자가 불리언 값이 아닌 경우 ⇒ 불리언 타입으로 암묵적 타입 변환

```jsx
!0; // true
!'Hello' // false
```

- 논리합(| |) or 논리곱(&&) 연산자 표현식
    - 평가 결과 ⇒ 불리언 값이 아닐 수 있음
    - 언제나 2개의 피연산자 중 어느 하나로 평가

```jsx
// 단축 평가
'Cat' && 'Dog'; // 'Dog'
```

- 드 모르간의 법칙
    - 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환

```jsx
!(x || y) === (!x && !y)
!(x && y) === (!x || !y)
```

<br/>

## 7.6 쉼표(,) 연산자

- 왼쪽 피연산자부터 차례대로 피연산자 평가
- 마지막 피연산자의 평가 종료 ⇒ 마지막 피연산자의 평가 결과 반환

```jsx
var x, y, z;
x = 1, y = 2, z = 3; // 3
```

<br/>

## 7.7 그룹 연산자

- 소괄호(’()’)로 피연산자를 감싸는 그룹 연산자
- 자신의 피연산자인 표현식을 가장 먼저 평가
- 그룹 연산자
    - 연산자 우선순위가 가장 높음

```jsx
10 * 2 + 3; // 23
10 * (2 + 3); // 50
```

<br/>

## 7.8 typeof 연산자

- 피연산자의 데이터 타입 ⇒ 문자열로 반환
- typeof 연산자
    - string
    - number
    - boolean
    - undefined
    - symbol
    - object
    - function
- null ⇒ 반환하는 경우 없음
- 함수는 function을 반환

```jsx
typeof '' // string
typeof 1 // number
typeof NaN // number
typeof true // boolean
typeof undefined // undefined
typeof Symbol() // symbol
typeof null // object
typeof [] // object
typeof {} // object
typeof new Date() // object
typeof /test/gi // object
typeof function () {} // function
```

- typeof 연산자
    - 선언하지 않은 식별자
    - typeof 연산자로 null 값 연산 ⇒ "null"이 아닌 "object" 반환
        - JavaScript 버그
    - null 타입 확인 ⇒ typeof 연산자가 아닌 일치 연산자(===) 사용해야 함
    
    ```jsx
    var foo = null;
    
    typeof foo == null; // false
    foo === null; // true
    ```
    
    - 선언하지 않은 식별자를 typeof 연산자로 연산 ⇒ ReferenceError 발생 X ⇒ undefined 반환
    
    ```jsx
    typeof undeclared; // undefined
    ```

<br/>

## 7.9 지수 연산자

- 좌항의 피연산자 == 밑 & 우항의 피연산자 == 지수 ⇒ 거듭 제곱 ⇒ 숫자 값 반환

```jsx
2 ** 2; // 4
2 ** 0; // 1
2 ** -2; // 0.25
```

- 지수 연산자 도입 전 ⇒ Math.pow 메서드

```jsx
Math.pow(2,2); // 4
Math.pow(2,0); // 1
```

- 지수 연산자 && Math.pow 메서드 가독성 비교

```jsx
2 ** (3 ** 2); // 512
Math.pow(2, Math.pow(3,2)); // 512
```

- 음수를 거듭제곱의 밑으로 사용해 계산하고자 하는 경우

```jsx
(-5) ** 2; // 25
```

- 할당 연산자와 함께 사용 가능

```jsx
var num = 5;
num **= 2; // 25
```

- 이항 연산자 중 우선 순위가 가장 높음

```jsx
2 * 5 ** 2; // 50
```

<br/>

## 7.10 그 외의 연산자

|연산자|개요|
|---|---|
|?.|옵셔널 체이닝 연산자|
|??|null 병합 연산자|
|delete|프로퍼티 삭제|
|new|생성자 함수를 호출할 때 사용하여 인스턴스를 생성|
|instanceof|좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별|
|in|프로퍼티 존재 확인|

<br/>

## 7.11 연산자의 부수 효과

- 다른 코드에 영향 X
- 일부 연산자 ⇒ 다른 코드에 영향을 주는 부수 효과 有
- 부수 효과 有 연산자
    - 할당 연산자(=)
    - 증가/감소 연산자(++/- -)
    - delete 연산자

<br/>

## 7.12 연산자 우선순위

- 여러 개의 연산자로 이뤄진 문 실행될 때 연산자가 실행되는 순서
- 우선순위가 높을수록 먼저 실행
- 연산자 우선순위가 가장 높은 그룹 연산자를 사용해서 우선순위를 명시적으로 조절하는 것을 권장

|우선순위|연산자|
|---|---|
|1|()|
|2|new(매개변수 존재), .. [](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자)|
|3|new(매개변수 미존재)|
|4|x++, x- -|
|5|!x, -x, ++x, - -x, typeof, delete|
|6|**(이항 연산자 중에서 우선순위가 가장 높다)|
|7|*, /, %|
|8|+, -|
|9|<, ≤, >, ≥, in, instanceof|
|10|==, ≠, ===, ≠=|
|11|??(null 병합 연산자)
|12|&&|
|13| 논리합 연산자 |
|14|? ... : ...|
|15|할당 연산자(=, +=, -=, ...)
|16|,|

<br/>

## 7.13 연산자 결합 순서

- 연산자 어느 쪽부터 평가를 수행할 것인지 나타내는 순서

|결합 순서|연산자|
|---|---|
|좌항 → 우항|+, -, /, %, <, ≤, >, ≥, &&, 논리합 연산자, ., [], ??, ?., in, instanceof|
|우항 → 좌항|++, --, 할당 연산자(=, +=, -=, ...), !x, +x, -x, ++x, --x, typeof, delete, ? ... : ...，**|
