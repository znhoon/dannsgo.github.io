---
published: true
title: "[JS] 함수"
categories:
 - WWW
tags:
 - [WWW, JavaScript]
toc: true
toc_sticky: true
---

📖 **모던 자바스크립트 Deep Dive** 책으로 공부하고 정리한 필기입니다.
{: .notice--primary}

## 12.1 함수란?

- JS에서 가장 중요한 핵심 개념
- JS의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등 ⇒ 모두 함수와 깊은 관련 有
- 수학의 함수
    - “입력(input)”을 받아 “출력(output)”을 내보내는 일련의 과정 정의
- 자바스크립의 함수
    - 수학의 함수와 같은 개념
    - 일련의 과정을 문(statement)으로 구현 & 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
    - 함수 내부로 입력을 전달받는 변수 ⇒ 매개 변수
    입력 ⇒ 인수
    출력 ⇒ 반환값
    - 함수 == 값
    - 여러 개 존재 가능
        - 특정 함수를 구별하기 위해 식별자인 함수 이름 사용 가능
    - 함수 정의를 통해 생성
    
    ```jsx
    // f(x, y) = x + y
    function add(x, y) {
    	return x + y;
    }
    
    // f(2, 5) = 7
    add(2, 5); // 7
    ```
    
    ![image](https://user-images.githubusercontent.com/90893596/153017102-02990773-b280-4d74-96fc-f832e4dd5abc.png)
    
- 함수 호출
    - 코드 블록에 담긴 문들이 일괄적으로 실행되고 반환값을 반환

<br/>

## 12.2 함수를 사용하는 이유

- 함수
    - 필요할 때 여러 번 호출 가능 ⇒ 코드 재사용 가능
    - 객체 타입의 값
    - 식별자를 붙일 수 있음
    - 실행 시점 ⇒ 개발자가 결정 가능 & 몇 번이든 재사용 가능
- 코드의 중복 억제 & 재사용성을 높이는 함수 ⇒ 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과 有
- 함수 리터럴의 구성 요소
    - 함수 이름
        - 함수 이름 == 식별자 ⇒ 식별자 네이밍 규칙 준수 필요
        - 함수 이름 == 함수 몸체 내에서만 참조할 수 있는 식별자
    - 매개변수 목록
        - 0개 이상의 매개변수 ⇒ 소괄호로 감싸고 쉼표로 구분
        - 함수를 호출할 때 지정한 인수가 순서대로 할당
        - 매개변수 목록 ⇒ 순서에 의미 有
        - 매개변수 ⇒ 함수 몸체 내에서 변수와 동일하게 취급
        - 변수와 마찬가지로 식별자 네이밍 규칙 준수 필요
    - 함수 몸체
        - 함수 호출 ⇒ 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록
        - 함수 몸체 ⇒ 함수 호출에 의해 실행
    - 함수 리터럴 ⇒ 평가되어 값 생성 ⇒ 값 == 객체
- 함수
    - 일반 객체와는 다름
    - 일반 객체 ⇒ 호출 불가능 but 함수 ⇒ 호출 가능
    - 일반 객체 ⇒ 없는 함수 객체만의 고유한 프로퍼티 有
- 자바스크립의 함수(=객체) ⇒ 중요한 특징

<br/>

## 12.4 함수 정의

- 함수 정의
    - 호출하기 이전에 인수를 전달받을 매개변수 & 실행할 문들 & 반환할 값 지정
- 정의된 함수
    - 자바스크립트 엔진에 의해 평가되어 함수 객체가 됨
- 함수를 정의하는 방법
    - 함수 선언문
        
        ```jsx
        function add(x, y){
        	return x + y;
        }
        ```
        
    - 함수 표현식
        
        ```jsx
        var add = function (x, y) {
        	return x + y;
        }；
        ```
        
    - Function 생성자 함수
        
        ```jsx
        var add = new Function( 'x', 'y', ' return x + y' )；
        ```
        
    - 화살표 함수(ES6)
        
        ```jsx
        var add = (x, y) => x + y;
        ```
        
- 변수 선언 & 함수 정의
    - 변수 ⇒ 선언
    - 함수 ⇒ 정의
    - 함수 선언문 평가 ⇒ 식별자 암묵적으로 생성 & 함수 객체가 할당됨

### 12.4.1 함수 선언문

- 함수 리터럴과 형태 동일
- 함수 리터럴 ⇒ 함수 이름 생략 가능
함수 선언문 ⇒ 함수 이름 생략 불가능
    - 이 점을 제외하면 함수 리터럴과 형태가 동일
- 표현식이 아닌 문
    - 변수에 할당 불가능
    - ∋ 함수 선언문
- `{ }`
    - 블록문 & 객체 리터럴 모두 가능
    - 중의적인 코드
    - 코드의 문맥에 따라 해석이 달라짐
    - 단독으로 존재 ⇒ 블록문으로 해석
    - 값으로 평가되어야 할 문맥에서 피연산자로 사용되는 경우 ⇒ 객체 리터럴로 해석
- 함수 리터럴
    - 중의적인 코드
    - 코드의 문맥에 따라 해석이 달라짐
    - 함수 몸체 외부에서 함수 이름으로 함수를 참조 불가능 ⇒ 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다는 의미
    - 함수를 가리키는 식별자 없음
    - 함수 이름이 있는 함수 리터럴 단독 사용 ⇒ 함수 선언문으로 해석
    - 함수 생성하는 내부 동작 차이 有
    - 기명 함수 리터럴(이름 有) ⇒ 코드의 문맥에 따라 함수 선언문 or 함수 리터럴 표현식으로 해석
    - 함수 선언문 & 함수 리터럴 표현식 ⇒ 함수 객체를 생성한다는 점에서 동일하지만 호출 차이 有
- 함수 선언문을 해석해 함수 객체 생성
- 함수 이름 ⇒ 함수 몸체 내부에서만 유효한 식별자
    - 함수 이름과는 별도로 생성된 함수 객체를 가리키는 식별자 필요
    - 함수 객체를 가리키는 식별자 없으면 생성된 함수 객체 참조 & 호출 불가
    - 생성된 함수 호출하기 위해 함수 이름 & 동일한 이름의 식별자를 암묵적으로 생성 && 식별자에 함수 객체 할당
- 함수 ⇒ 함수 이름으로 호출하는 것 X, 함수 객체를 가리키는 식별자로 호출
    - 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있지만, 함수 선언문과 함수 표현식이 정확히 동일하게 동작하는 것 X

### 12.4.2 함수 표현식

- 자바스크립트의 함수
    - == 객체 타입의 값
    - 값처럼 변수에 할당 가능
    - 프로퍼티 값 & 배열의 요소 가능
    - 일급 객체
    - 함수 리터럴로 생성한 함수 객체를 변수에 할당 가능 ⇒ 함수 표현식
- 일급 객체
    - 값의 성질을 갖는 객체
    - 함수를 값처럼 자유롭게 사용할 수 있다는 의미
- 익명 함수
    - 함수 리터럴의 함수 이름 생략
    - 함수 표현식의 함수 리터럴 ⇒ 함수 이름 생략하는 것이 일반적
- 함수 호출  ⇒ 함수 이름이 아닌 함수 객체를 가리키는 식별자 사용
    - 함수 이름 ⇒ 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 함수 호출 불가능
- 함수 선언문 & 함수 표현식이 정확히 동일하게 동작 X
    - 함수 선언문 == “표현식이 아닌 문”
    함수 표현식 == “표현식인 문”

### 12.4.3 함수 생성 시점과 함수 호이스팅

```jsx
// 함수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console. log(sub( 2, 5)); // Type Error: sub is not a function

// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 표현식
var sub = function (x, y) {
	return x - y;
}；
```

- 함수 선언문으로 함수 정의 ⇒ 런타임 이전에 함수 객체가 먼저 생성
    - 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성 & 생성된 함수 객체 할당
- 함수 호이스팅
    - 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
    - 함수 호이스팅 ≠ 변수 호이스팅
    - 함수 선언문으로 정의한 함수 ⇒ 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출 가능
- 함수 표현식
    - 변수에 할당되는 값이 함수 리터럴인 문
    - 변수 선언문 & 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작
    - 변수 선언
        - 런타임 이전에 실행되어 undefined로 초기화
        - 런타임(변수 할당문의 값 ⇒ 할당문이 실행되는 시점)에 평가되어 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨
    - 함수 표현식
        - 함수 정의 ⇒ 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생함
        - 함수 표현식 이전에 함수 참조 ⇒ undefined 평가
        - 함수 호출 ⇒ undefined 호출하는 것과 마찬가지로 타입 에러 발생
            - 함수 선언문 대신 함수 표현식 사용할 것을 권장

### 12.4.4 Function 생성자 함수

- 매개변수 목록 & 함수 몸체
    - 문자열로 전달 & new 연산자와 함께 호출하면 함수 객체를 생성해서 반환
    - new 연산자 없이 호출해도 결과는 동일
- 생성자 함수
    - 객체를 생성하는 함수
    - 객체 생성하는 방식
        - 객체 리터럴 이외에 다양한 방법 有
- Function 생성자 함수로 생성한 함수
    - 일반적 X & 바람직 X
    - 클로저 생성 X
    - 함수 선언문 or 함수 표현식으로 생성한 함수와 다르게 동작
    - 함수 선언문 or 함수 표현식으로 생성한 함수 && Function 생성자 함수로 생성한 함수가 동일하게 동작 X

### 12.4.5 화살표 함수

- ES6 ⇒ function 키워드 대신 화살표(⇒) 사용해서 간략한 방법으로 함수 선언
- 항상 익명 함수로 정의

```jsx
// 화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

- 기존의 함수 선언문 or 함수 표현식을 완전히 대체하기 위해 디자인된 것 X
- 기존의 함수보다 표현만 간략한 것이 아닌 내부 동작 또한 간략화
- 생성자 함수로 사용 불가능
- 기존 함수와 this 바인딩 방식 다름
- prototype 프로퍼티 X
- arguments 객체 생성 X

<br/>

## 12.5 함수 호출

### 12.5.1 매개변수와 인수

- 함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우 ⇒ 매개변수를 통해 인수를 전달
    - 인수
        - 값으로 평가될 수 있는 표현식
        - 함수를 호출할 때 지정 && 개수와 타입 제한 X
    - 매개변수
        - 함수를 정의할 때 선언
        - 함수 몸체 내부에서 변수와 동일하게 취급
        - 함수 몸체 내부에서만 참조 가능(매개변수의 스코프 == 함수 내부)
- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크 X ⇒ 에러 발생 X
- 초과된 인수 ⇒ 암묵적으로 arguments 객체의 프로퍼티로 보관됨

### 12.5.2 인수 확인

- ES6에서 도입된 매개변수 기본값 사용 ⇒ 함수 내에서 수행하던 인수 체크 및 초기화 간소화
- 매개변수 기본값
    - 매개변수에 인수를 전달하지 않았을 경우 & undefined를 전달한 경우만 유효

### 12.5.3 매개변수의 최대 개수

- 매개변수의 최대 개수에 대한 제한 有
- 순서 의미 有
    - 매개변수 多 ⇒ 함수를 호출할 때 전달해야 할 인수의 순서 고려해야 함
- 이상적인 매개변수 개수 == 0개
    - 적을수록 좋음
- 이상적인 함수 ⇒ 1가지 일만 해야하며, 작게 만들어야 함
- 매개변수는 최대 3개 이상을 넘지 않는 것을 권장
    - 그 이상의 매개변수가 필요하다면 하나의 매개변수 선언 & 객체를 인수로 전달하는 것이 유리
- 객체를 인수로 사용하는 경우
    - 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경 쓰지 않아도 됨
    - 인수의 의미를 설명하는 프로퍼티 키 사용 ⇒ 코드의 가독성도 좋아지고 실수도 줄어드는 효과 有
    - 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경 ⇒ 함수 외부의 객체가 변경되는 부수 효과 발생

### 12.5.4 반환문

- 함수는 return 키워드 & 표현식(반환값)으로 이뤄진 반환문 사용 ⇒ 실행 결과를 함수 외부로 반환 가능
- 함수 호출 == 표현식
- 함수 호출 표현식 == return 키워드가 반환한 표현식의 평가 결과
- 반환문 역할
    - 함수의 실행을 중단하고 함수 몸체 탈출
    - return 키워드 뒤에 오는 표현식 평가해서 반환
- 함수 내부에서만 사용 가능
- Node.js
    - 모듈 시스템에 의해 파일별로 독립적인 파일 스코프 갖음 ⇒ 파일의 가장 바깥 영역에서 반환문을 사용해도 에러 발생 X

<br/>

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 값에 의한 호출 & 참조에 의한 호출
- 객체를 불변 객체로 만들어 사용하는 게 좋음
    - 외부 상태가 변경되는 부수 효과 없앨 수 있음
- 순수 함수
    - 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
- 함수형 프로그래밍
    - 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임

<br/>

## 12.7 다양한 함수의형태

### 12.7.1 즉시 실행 함수

- 함수 정의와 등시에 즉시 호출되는 함수
- 단 한 번만 호출되며 다시 호출할 수 없음
- 함수 이름이 없는 익명 함수를 사용하는 것이 일반적
    - 함수 이름이 있는 기명 즉시 실행 함수도 사용 가능
        - 그룹 연산자 ( ... ) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴
        로 평가 ⇒ 즉시 실행 함수를 다시 호출할 수 없음
- 즉시 실행 함수는 반드시 그룹 연산자 ( ... )로 감싸야 함
- 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지 가능

### 12.7.2 재귀함수

- 함수가 자기 자신을 호출하는 것
- 재귀 함수
    - 자기 자신을 호출하는 행위
    - 재귀 호출을 수행하는 함수
    - 반복되는 처리를 위해 사용
    - 팩토리얼 구현 가능
    - 자신을 무한 재귀 호출
    - 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 함
    - 함수 외부에서 함수를 호출할 때는 반드시 함수를 가리키는 식별자 사용

### 12.7.3 중첩 함수

- == 내부 함수
- 함수 내부에 정의된 함수
- 외부 함수 내부에서만 호출 가능
    - 외부 함수
        - 중첩 함수를 포함하는 함수
- 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할
- ES6부터 함수정의 ⇒ 문이 위치할 수 있는 문맥이라면 어디든지 가능
- 스코프 & 클로저와 깊은 관련 有

### 12.7.4 콜백 함수

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 고차 함수에 전달되어 헬퍼 함수의 역할
    - 고차 함수
        - 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
        - 콜백 함수를 자신의 일부분으로 합성
        - 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출
- 고차 함수에 의해 호출
    - 고차 함수는 필요에 따라 콜백 함수에 인수를 전달
- 고차 함수에 콜백 함수를 전달할 때 콜백 함수를 호출하지 않고 함수 자체를 전달해야 함
- 일반적으로 콜백 함수가 고차 함수 내부에만 호출 ⇒ 콜백 함수를 익명 함수 리터럴로 정의 & 곧바로 고차 함수에 전달
- 비동기 처리(이벤트 처리, Ajax 통신，타이머 함수 등)에 활용되는 중요한 패턴
- 비동기 처리뿐 아니라 배열 고차 함수에서도 사용

### 12.7.5 순수 함수와 비순수 함수

- 순수 함수
    - 어떤 외부 상태에도 의존하지 않으며 외부 상태를 변경하지도 않는 함수
    - 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수
    - 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 값을 생성해 반환
- 비순수 함수
    - 함수의 외부 상태에 따라 반환값이 달라지는 함수
    - 외부 상태에 의존하는 함수
    - 부수 효과 有
    - 외부 상태에 의존하거나 외부 상태를 변경하는 함수
    - 외부 상태 변경 가능
    - 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 객체를 전달받는으면 비순수 함수
